# 动态规划(Dynamic Programming)
动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，**将其不同阶段的不同状态保存在一个二维数组中[最优决策表]**，它是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等）
## 能用动规解决的问题的特点
- 问题具有最优子结构性质。
- 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或
经过哪条路径演变到当前的这若干个状态，没有关系
- 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
## 动规解题的一般思路
递归函数有n个参数，就定义一个n维的数组(*根据求解域可以优化*)，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。
- 将原问题分解为子问题
- 定义每个阶段的状态
- 确定一些初始状态（边界状态）的值
- 状态转移方程(关键):从前一个阶段转化到后一个阶段之间的递推关系
## 案例
- 最长公共子字串
    ```转移方程
        dp[0][j] = 0; (0<=j<=m)
        dp[i][0] = 0; (0<=i<=n)
        dp[i][j] = dp[i-1][j-1] +1; (str1[i] == str2[j])
        dp[i][j] = 0; (str1[i] != str2[j])
    ```
- 最长公共子序列
    ```转移方程
        dp[0][j] = 0; (0<=j<=m)
        dp[i][0] = 0; (0<=i<=n)
        dp[i][j] = dp[i-1][j-1] +1; (str1[i-1] == str2[j-1])
        dp[i][j] = max{dp[i][j-1],dp[i-1][j]}; (str1[i-1] != str2[j-1])
    ```
- 最大子序列和
    ```
        dp[1] = a1; (a1>=0 && i == 1)
        dp[i] = dp[i-1]+ai; (ai>=0 && i>=2)
        dp[i] = 0; (dp[i-1] + ai <=0 && i>=2)
    ```
- 最长递增子序列
    ```
        dp[0] = 1;
        dp[i] = max(dp[j])+1, (a[i]<a[j], 0<j<i<N)
    ```
- 最长不含重复元素的子串
    ```
        dp[0] = 1;
        dp[i] = i - j; (a[j]=a[i], 0<j<i<N)
        dp[i] = dp[i-1]+1, (a[j]!=a[i], 0<j<i<N)
    ```