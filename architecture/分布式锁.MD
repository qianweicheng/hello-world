# 分布式锁
参考: https://zhuanlan.zhihu.com/p/42056183
## 基于Redis方案，得益于其单进程单线程模式
#### Redis事务+WATCH:
CAS思路
严格意义来讲,Redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的；Redis的事务实质上是命令的集合，在一个事务中要么所有命令都被执行，要么所有事物都不执行。 
`WATCH MULTI EXEC DISCARD UNWATCH`
一个事务从开始到执行会经历以下三个阶段：
- 开始事务。
- 命令入队。
- 执行事务。
#### 分布式锁
- 初步思路: `setnx key value`, 但存在问题死锁的风险(客户端挂掉了)
- 解决思路
  - 使用 `setnx key` “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现. `通过GETSET，客户端2拿到的时间戳如果仍然是超时的，那就说明，客户端2如愿以偿拿到锁了`
    缺陷: 客户端1释放锁，客户端2和客户端3竞争，客户端2没拿到锁，但它改写了客户端3设置的锁的超时值, 不过该缺陷的副作用非常小
  - 通过Redis中expire()给锁设定最大持有时间，等待到超时让Redis释放锁
    缺陷: 故障发生在`setnx key` 和 `expire`之间可能导致死锁
最终解决方案:
## 基于Zookeeper
略
## 比较
分布式锁|优点|缺点
-|-|-
Zookeeper|有封装好的框架，容易实现,有等待锁的队列，大大提升抢锁效率。|添加和删除节点性能较低
Redis|Set和Del指令性能较高|实现复杂，需要考虑超时，原子性，误删等情形。没有等待锁的队列，只能在客户端自旋来等待，效率低下。
